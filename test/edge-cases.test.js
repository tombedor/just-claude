const { test } = require('node:test');
const assert = require('node:assert');
const fs = require('fs');
const path = require('path');
const { extractRecipes, generateSkills, isGeneratedSkill } = require('../lib/generator.js');

// Helper to create temporary test directory
function createTempDir() {
  const tmpDir = path.join('/tmp', `just-claude-test-${Date.now()}`);
  fs.mkdirSync(tmpDir, { recursive: true });
  return tmpDir;
}

// Helper to cleanup temp directory
function cleanupDir(dir) {
  if (fs.existsSync(dir)) {
    fs.rmSync(dir, { recursive: true, force: true });
  }
}

test('no public recipes - only private', () => {
  const justfileData = {
    recipes: {
      _private1: {
        name: '_private1',
        namepath: '_private1',
        private: true,
        parameters: []
      },
      _private2: {
        name: '_private2',
        namepath: '_private2',
        private: true,
        parameters: []
      }
    }
  };

  const recipes = extractRecipes(justfileData);
  assert.strictEqual(recipes.length, 0);
});

test('empty justfile', () => {
  const justfileData = {
    recipes: {}
  };

  const recipes = extractRecipes(justfileData);
  assert.strictEqual(recipes.length, 0);
});

test('skill name conflict - generated skill', () => {
  const tmpDir = createTempDir();

  try {
    // Create a generated skill
    const skillDir = path.join(tmpDir, '.claude', 'skills', 'just-test');
    fs.mkdirSync(skillDir, { recursive: true });
    fs.writeFileSync(
      path.join(skillDir, 'SKILL.md'),
      '<!-- Generated by just-claude -->\nTest content',
      'utf-8'
    );

    assert.strictEqual(isGeneratedSkill(skillDir), true);
  } finally {
    cleanupDir(tmpDir);
  }
});

test('skill name conflict - manual skill', () => {
  const tmpDir = createTempDir();

  try {
    // Create a manual skill (no generated marker)
    const skillDir = path.join(tmpDir, '.claude', 'skills', 'just-test');
    fs.mkdirSync(skillDir, { recursive: true });
    fs.writeFileSync(
      path.join(skillDir, 'SKILL.md'),
      'Manual skill content',
      'utf-8'
    );

    assert.strictEqual(isGeneratedSkill(skillDir), false);
  } finally {
    cleanupDir(tmpDir);
  }
});

test('generateSkills - skip manual skills', () => {
  const tmpDir = createTempDir();

  try {
    // Create a manual skill
    const manualSkillDir = path.join(tmpDir, '.claude', 'skills', 'just-manual');
    fs.mkdirSync(manualSkillDir, { recursive: true });
    fs.writeFileSync(
      path.join(manualSkillDir, 'SKILL.md'),
      'Manual skill - do not overwrite',
      'utf-8'
    );

    // Generate skills with a recipe named 'manual'
    const justfileData = {
      recipes: {
        manual: {
          name: 'manual',
          namepath: 'manual',
          doc: 'This should be skipped',
          parameters: [],
          private: false
        },
        auto: {
          name: 'auto',
          namepath: 'auto',
          doc: 'This should be generated',
          parameters: [],
          private: false
        }
      }
    };

    generateSkills(tmpDir, justfileData);

    // Manual skill should not be overwritten
    const manualContent = fs.readFileSync(path.join(manualSkillDir, 'SKILL.md'), 'utf-8');
    assert.strictEqual(manualContent, 'Manual skill - do not overwrite');

    // Auto skill should be generated
    const autoSkillDir = path.join(tmpDir, '.claude', 'skills', 'just-auto');
    assert.ok(fs.existsSync(path.join(autoSkillDir, 'SKILL.md')));

    const autoContent = fs.readFileSync(path.join(autoSkillDir, 'SKILL.md'), 'utf-8');
    assert.ok(autoContent.includes('<!-- Generated by just-claude'));
  } finally {
    cleanupDir(tmpDir);
  }
});

test('generateSkills - overwrite existing generated skill', () => {
  const tmpDir = createTempDir();

  try {
    // Create an old generated skill
    const skillDir = path.join(tmpDir, '.claude', 'skills', 'just-build');
    fs.mkdirSync(skillDir, { recursive: true });
    fs.writeFileSync(
      path.join(skillDir, 'SKILL.md'),
      '<!-- Generated by just-claude -->\nOld content',
      'utf-8'
    );

    // Generate new skill with updated content
    const justfileData = {
      recipes: {
        build: {
          name: 'build',
          namepath: 'build',
          doc: 'New description',
          parameters: [],
          private: false
        }
      }
    };

    generateSkills(tmpDir, justfileData);

    // Should be overwritten with new content
    const content = fs.readFileSync(path.join(skillDir, 'SKILL.md'), 'utf-8');
    assert.ok(content.includes('New description'));
    assert.ok(!content.includes('Old content'));
  } finally {
    cleanupDir(tmpDir);
  }
});

test('large justfile - many recipes', () => {
  const recipes = {};

  // Create 150 recipes
  for (let i = 0; i < 150; i++) {
    recipes[`recipe${i}`] = {
      name: `recipe${i}`,
      namepath: `recipe${i}`,
      doc: `Recipe ${i}`,
      parameters: [],
      private: false
    };
  }

  const justfileData = { recipes };
  const extracted = extractRecipes(justfileData);

  assert.strictEqual(extracted.length, 150);
});

test('nested modules - multiple levels', () => {
  const justfileData = {
    recipes: {
      root: {
        name: 'root',
        namepath: 'root',
        private: false,
        parameters: []
      }
    },
    modules: {
      level1: {
        recipes: {
          mid: {
            name: 'mid',
            namepath: 'level1::mid',
            private: false,
            parameters: []
          }
        },
        modules: {
          level2: {
            recipes: {
              deep: {
                name: 'deep',
                namepath: 'level1::level2::deep',
                private: false,
                parameters: []
              }
            }
          }
        }
      }
    }
  };

  const recipes = extractRecipes(justfileData);

  assert.strictEqual(recipes.length, 3);
  assert.ok(recipes.some(r => r.namepath === 'root'));
  assert.ok(recipes.some(r => r.namepath === 'level1::mid'));
  assert.ok(recipes.some(r => r.namepath === 'level1::level2::deep'));
});
